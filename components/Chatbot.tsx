import React, { useState, useCallback } from 'react';
import { ChatWindow } from './ChatWindow';
import { sendMessage } from '../services/geminiService';
import type { ChatMessage, MessageContent, Article, DrugTarget } from '../types';
import { Author } from '../types';

// Dummy content for the PDB downloader feature until a real mutation endpoint is available.
const DUMMY_PDB_CONTENT = `
HEADER    MUTATED PROTEIN STRUCTURE    29-JUL-24   XXXX
TITLE     DUMMY FILE GENERATED BY DR. RHESUS
ATOM      1  N   MET A   1      27.289  35.815  25.489  1.00 17.65           N
ATOM      2  CA  MET A   1      27.915  36.957  24.843  1.00 17.38           C
ATOM      3  C   MET A   1      29.431  36.711  24.885  1.00 16.59           C
ATOM      4  O   MET A   1      29.954  35.862  25.568  1.00 17.19           O
END
`.trim();

function Chatbot() {
  const [messages, setMessages] = useState<ChatMessage[]>([
    {
      id: 'initial-message',
      author: Author.AI,
      content: [{ type: 'text', text: "Hello! I’m Dr. Rhesus from The Dream Lab. I’m here to assist you with knowledge, ideas, and exploration. What would you like to discover today?" }],
      rawText: "Hello! I’m Dr. Rhesus from The Dream Lab. I’m here to assist you with knowledge, ideas, and exploration. What would you like to discover today?",
    },
  ]);
  const [isLoading, setIsLoading] = useState(false);

  /**
   * Parses the raw text response from the AI and splits it into structured
   * content parts (text, visualizations, lists, etc.) based on predefined rules.
   */
  const parseAIResponse = (text: string): MessageContent[] => {
    const content: MessageContent[] = [];
    let remainingText = text;

    // Rule for advanced visualization: <visualization>{...}</visualization>
    const vizRegex = /<visualization>([\s\S]*?)<\/visualization>/;
    const vizMatch = remainingText.match(vizRegex);
    if (vizMatch) {
      const preText = remainingText.substring(0, vizMatch.index).trim();
      if (preText) {
        content.push({ type: 'text', text: preText });
      }
      try {
        const vizJson = JSON.parse(vizMatch[1]);
        content.push({
          type: 'pdb_visualization',
          pdbId: vizJson.pdbId,
          actions: vizJson.actions
        });
      } catch (e) {
        console.error("Failed to parse visualization JSON:", e);
        content.push({ type: 'text', text: "Sorry, I had an issue generating the visualization data." });
      }
      remainingText = remainingText.substring(vizMatch.index! + vizMatch[0].length).trim();
    }

    // Rule for simple PDB viewer: (PDB ID: XXXX)
    const pdbRegex = /I am now displaying the 3D structure for you\.\s*\(PDB ID: (\w{4})\)/i;
    const pdbMatch = remainingText.match(pdbRegex);
    if (pdbMatch) {
      const preText = remainingText.substring(0, pdbMatch.index).trim();
      if (preText) {
        content.push({ type: 'text', text: preText });
      }
      content.push({ type: 'pdb_visualization', pdbId: pdbMatch[1] });
      remainingText = remainingText.substring(pdbMatch.index! + pdbMatch[0].length).trim();
    }
    
    // Rule for downloader: "You can download..."
    const downloadRegex = /You can download the mutated PDB file\./i;
    const downloadMatch = remainingText.match(downloadRegex);
    if (downloadMatch) {
        const preText = remainingText.substring(0, downloadMatch.index).trim();
        if(preText){
            content.push({ type: 'text', text: preText});
        }
        content.push({ type: 'text', text: "You can download the mutated PDB file." });
        content.push({ type: 'downloader', pdbContent: DUMMY_PDB_CONTENT, filename: 'mutated_protein.pdb'});
        remainingText = remainingText.substring(downloadMatch.index! + downloadMatch[0].length).trim();
    }

    // Rule for Drug Targets: "Based on current research..."
    const drugTargetHeaderRegex = /Based on current research, here are potential drug targets for (.*?):/i;
    const drugTargetHeaderMatch = remainingText.match(drugTargetHeaderRegex);
    if(drugTargetHeaderMatch) {
        const pathogen = drugTargetHeaderMatch[1].trim();
        const targets: DrugTarget[] = [];
        const targetListText = remainingText.substring(drugTargetHeaderMatch.index! + drugTargetHeaderMatch[0].length);
        const targetRegex = /\d+\.\s+\*\*Name:\*\*\s*(.*?)\s*\n\*\*Function:\*\*\s*(.*?)\s*\n\*\*Rationale:\*\*\s*(.*?)(?=\n\d+\.|\n*$)/gs;
        let match;
        while ((match = targetRegex.exec(targetListText)) !== null) {
            targets.push({
                name: match[1].trim(),
                function: match[2].trim(),
                rationale: match[3].trim(),
            });
        }
        if (targets.length > 0) {
            const preText = remainingText.substring(0, drugTargetHeaderMatch.index).trim();
            if(preText){
                content.push({ type: 'text', text: preText });
            }
            content.push({ type: 'drug_target_list', targets, pathogen });
            remainingText = ""; // Assume the rest of the text was part of the list
        }
    }

    // Rule for articles (basic parsing for a list of bolded titles and summaries)
    const articleHeaderRegex = /Here are the key findings from recent literature:|Here are some relevant articles:/i;
    if (articleHeaderRegex.test(remainingText)) {
        const articles: Article[] = [];
        const articleRegex = /\d+\.\s+\*\*(.*?)\*\*\s*-\s*(.*?)(?=\n\d+\.|\n\n|$)/gs;
        let match;
        while ((match = articleRegex.exec(remainingText)) !== null) {
            articles.push({ title: match[1].trim(), summary: match[2].trim() });
        }
        if (articles.length > 0) {
            const listStartIndex = remainingText.search(/\d+\.\s+\*\*/);
            if (listStartIndex !== -1) {
                const preText = remainingText.substring(0, listStartIndex).trim();
                if(preText) {
                     content.push({ type: 'text', text: preText });
                }
                content.push({ type: 'article_list', articles });
                remainingText = ""; // Assume rest of text was the list
            }
        }
    }

    // Any text that hasn't been parsed into a special component is added as a final text block.
    if (remainingText) {
      content.push({ type: 'text', text: remainingText });
    }

    // If no special content was found, return the original text as a single block.
    return content.length > 0 ? content : [{ type: 'text', text }];
  };

  const handleSendMessage = useCallback(async (userInput: string) => {
    if (!userInput.trim() || isLoading) return;

    const userMessage: ChatMessage = {
      id: `user-${Date.now()}`,
      author: Author.USER,
      content: [{ type: 'text', text: userInput }],
    };

    const newMessages = [...messages, userMessage];
    setMessages(newMessages);
    setIsLoading(true);

    try {
      const aiResponseText = await sendMessage(newMessages);
      const parsedContent = parseAIResponse(aiResponseText);

      const aiMessage: ChatMessage = {
        id: `ai-${Date.now()}`,
        author: Author.AI,
        content: parsedContent,
        rawText: aiResponseText, // Store the original text for history
      };
      setMessages((prevMessages) => [...prevMessages, aiMessage]);
    } catch (error) {
      console.error("Failed to get response from AI:", error);
      const errorMessage: ChatMessage = {
        id: `error-${Date.now()}`,
        author: Author.AI,
        content: [{ type: 'text', text: "I'm sorry, but I seem to be having trouble connecting to my research databases. Please try again later." }],
        rawText: "I'm sorry, but I seem to be having trouble connecting to my research databases. Please try again later.",
      };
      setMessages((prevMessages) => [...prevMessages, errorMessage]);
    } finally {
      setIsLoading(false);
    }
  }, [isLoading, messages]);

  return (
    <div className="flex flex-col h-full bg-gray-900">
      <header className="bg-gray-800 border-b border-blue-400/30 p-4 shadow-lg flex items-center shrink-0">
        <div className="w-10 h-10 bg-blue-500 rounded-full flex items-center justify-center text-xl font-bold mr-4 shrink-0">
          Dr
        </div>
        <div>
          <h1 className="text-xl font-bold text-blue-300">Dr. Rhesus</h1>
          <p className="text-sm text-gray-400">AI Research Assistant</p>
        </div>
      </header>
      <main className="flex-1 overflow-y-auto p-4 md:p-6">
        <ChatWindow messages={messages} isLoading={isLoading} onSendMessage={handleSendMessage} />
      </main>
    </div>
  );
}

export default Chatbot;
